## Chapter 3 - SERVICE CREATION
> Designed! Congratz! :boom:  
> Time to make it real! Let's create our ACL_SERVICE! :construction_worker:

### 1st step - Generate skeleton of the service:
Let's first generate skeleton of our ACL_SERVICE and take a look on its structure.  

To achieve that - navigate to the `packages` folder inside `/opt/ncs-run` directory:
```
root@ad720ce13193:/opt/ncs-run# cd packages/
```

And generate a skeleton of our `ACL_SERVICE`:
```
root@ad720ce13193:/opt/ncs-run/packages# ncs-make-package --service-skeleton python-and-template ACL_SERVICE
```

Created! 
Go inside of our package and check what's there:
```
root@ad720ce13193:/opt/ncs-run/packages# cd ACL_SERVICE
root@ad720ce13193:/opt/ncs-run/packages/ACL_SERVICE# ls
README  package-meta-data.xml  python  src  templates  test
```
By default generated package structure looks following:
<img src="/readme/fulltopo.png"></img>

We're going to take care of its 3 parts:  
- <b>XML TEMPLATE</b> - /template/ACL_SERVICE-template.xml  
- <b>YANG DATA MODEL</b> - /src/yang/ACL_SERVICE.yang    
- <b>PYTHON LOGIC</b> (optional) - /python/ACL_SERVICE/main.py  

Open these 3 files in the text editor - for example, Visual Studio Code.


### 2nd step - Create XML TEMPLATE

First part is an XML template of our Service - this will be an actual config pushed to the device.

<img src="/readme/temp.png"></img>

This is an initial XML template generated by default: <br>
<p align="center">
<img width=460 src="/readme/xml_init.png"></img>
</p>

Log in back to NSO:
```
ncs_cli -C -u admin
```

Go into config mode:
```
config
```

Put sample config on NSO CLI and generate XML from it.

First for IOS device:
```
devices device IOS0 config ios:ip access-list standard ACL_CLUS
permit 172.16.0.0 0.0.255.255
deny 192.168.34.0 0.0.0.255

devices device IOS0 config ios:interface GigabitEthernet 0/0
ip access-group ACL_CLUS in
```

Print this configuration as XML:
```
commit dry-run outformat xml
```

Copy all output between **<config\>** **</config\>** tags from the CLI and paste it to our initial XML template **ACL_SERVICE-template.xml** as well between **<config\>** **</config\>** tags:
<img src="init temp.png"></img>

Great! We only wanted to generate the structure of XML. Don't commit that configuration to the device, abort it:
```
admin@ncs(config-if)# abort
```

Go again to the config mode:
```
admin@ncs# config
```

And repeat all steps for IOS-XR:
```
devices device IOS_XR0 config cisco-ios-xr:ipv4 access-list ACL_CLUS
10 permit 172.16.0.0 0.0.255.255
20 deny 192.168.34.0 0.0.0.255

devices device IOS_XR0 config cisco-ios-xr:interface GigabitEthernet 0/0
ipv4 access-group ACL_CLUS ingress
```

As well as Juniper:
```
devices device JUN0 config junos:configuration firewall family inet filter ACL_CLUS 
term 10 from source-address 172.16.0.0/16
exit
then accept
exit
term 20 from source-address 192.168.34.0/24
exit
then reject

devices device JUN0 config junos:configuration interfaces interface xe-0/0/0 unit 0 family inet filter input filter-name ACL_CLUS
```

Once you're done - the complete template **ACL_SERVICE-template.xml** with our ACL configs for IOS, IOS-XR and JUNIPER should looks like that (with configs for all vendors pasted one by one):
<p align="center">
<img width=640 src="/readme/template_full.png"></img>
</p>

Congratz! You have prepared all devices configuration for our Service! But wait... there're now fixed values. 

Let's update the template with our parametrized **variables** from the previous Chapter - **interface** and **direction**!

Parameter | IOS  | IOS-XR | Juniper
------------ | ------------- | ------------- | -------------
interface | GigabitEthernet `[int_number]` | GigabitEthernet `[int_number]` | `[int]`
direction | `[in/out]` | `[in/out]` | `[input/output]`  

IOS:
<img src="/readme/iosparam.png"></img>

Do it as well for IOS-XR. It's very similar to IOS:
<img src="/readme/xrparam.png"></img>

Juniper requires a little bit different change. 
Parametrization of the **interface** will be the same but **direction** here is not a value (like 'input'/'output') - it's an **XML tag**, so you need to use **when statement** to be able to activate the particular, desired tag:
<img src="/readme/junparam.png"></img>

That's it, we're done with templating! Congratz!


### 3rd step - Create YANG DATA MODEL

Second part is a YANG Data Model of our Service - this will give us an opportunity to provide the CLI interface to configure our Service exactly in that way that we want to have. 
<img src="/readme/yang.png"></img>


This is our generated YANG Skeleton:
<img src="/readme/yangxml.png"></img>


Hmmm... what was our Service design from the previous Chapter?
```
ACL_SERVICE [device] interface [int] direction [in|out]
```

Parameter | IOS  | IOS-XR | Juniper
------------ | ------------- | ------------- | -------------
interface | GigabitEthernet `[int]` | GigabitEthernet `[int]` | `[int]`
direction | `[in/out]` | `[in/out]` | `[input/output]` 

```
ACL_SERVICE (Key: Device)
- device
- ios:
      + interface -> leafref to device GigabitEthernet int
      + direction -> enum: in/out
- xr:
      + interface -> leafref to device GigabitEthernet int
      + direction -> enum: in/out
- junos:
      + interface -> leafref to device int
      + direction -> enum: input/output
```

To be able to get device parameters, we need to first connect our package with NEDs:
```
root@241df8db8028:/opt/ncs-run/packages/ACL_SERVICE# cd src/
sed -i '13i YANGPATH += ../../cisco-ios/src/ncsc-out/modules/yang \\' Makefile*
sed -i '14i YANGPATH += ../../cisco-iosxr/src/ncsc-out/modules/yang \\' Makefile*
sed -i '15i YANGPATH += ../../juniper-junos/src/ncsc-out/modules/yang \\' Makefile*
```

Let's model it in YANG and make some changes to the initial one:
```
module ACL_SERVICE {

  namespace "http://example.com/ACL_SERVICE";
  prefix ACL_SERVICE;

  import ietf-inet-types {
    prefix inet;
  }
  import tailf-common {
    prefix tailf;
  }
  import tailf-ncs {
    prefix ncs;
  }
  import tailf-ned-cisco-ios {
    prefix ios;
  }
  import tailf-ned-cisco-ios-xr {
    prefix iosxr;
  }
  import junos {
    prefix junos;
  }

  description
    "Bla bla...";

  revision 2016-01-01 {
    description
      "Initial revision.";
  }

  list ACL_SERVICE {
    description "This is an RFS skeleton service";

    key "device";
    uses ncs:service-data;
    ncs:servicepoint ACL_SERVICE-servicepoint;

    leaf device {
      type leafref {
        path "/ncs:devices/ncs:device/ncs:name";
      }
    }

    container ios {
        tailf:cli-drop-node-name;
        when "(contains(deref(../device)/../ncs:platform/ncs:name, 'ios'))" {
        tailf:dependency "../device";
        }
        leaf interface {
        type leafref {
          path "deref(../../device)/../ncs:config/ios:interface/ios:GigabitEthernet/ios:name";
          }
        }
        leaf direction {
          type enumeration { 
            enum in; 
            enum out; 
          }
        }
    }

      container xr {
        tailf:cli-drop-node-name;
        when "(contains(deref(../device)/../ncs:platform/ncs:name, 'ios-xr'))" {
        tailf:dependency "../device";
        }
        leaf interface {
        type leafref {
          path "deref(../../device)/../ncs:config/iosxr:interface/iosxr:GigabitEthernet/iosxr:id";
          }
        }
        leaf direction {
          type enumeration { 
            enum in; 
            enum out; 
          }
        }
      }

      container junos {
        tailf:cli-drop-node-name;
        when "(contains(deref(../device)/../ncs:platform/ncs:name, 'junos'))" {
        tailf:dependency "../device";
        }
        leaf interface {
        type leafref {
          path "deref(../../device)/../ncs:config/junos:configuration/junos:interfaces/junos:interface/junos:name";
          }
        }
        leaf direction {
          type enumeration { 
            enum input; 
            enum output; 
          }
        }
      }

  }
}
```

After creation of the model, go back to the ACL_SERVICE folder and navigate to the `src` folder: 
```
root@241df8db8028:/opt/ncs-run/packages/ACL_SERVICE# cd src/
```

Compile the package executing command (it will take a while):
```
make clean all
```

Done! You have the core functionality of our ACL_SERVICE!

### 4th step - Create PYTHON LOGIC (optional)

Third part is a Python code of our Service - this will give us an opportunity to provide logic to our Service if we need to calculate something before appending to the template or provide some data to configure from 3rd party.

<img src="/readme/python.png"></img>

---
<h4 align="center">[6/9]</h4>
<h4 align="center"> <a href="/readme/4.md"> :arrow_left: Design the Service! </a> || <a href="/readme/6.md"> Deploy the Service! :arrow_right: </a> </h4>
